<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="MAIN" Id="{33eb6f49-7781-4211-a70b-87ada6d80cb7}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
    sVersion: STRING := '1.0.0';
    afbAxes: ARRAY [1..GVL_APP.nAXIS_NUM] OF FB_Axis;
    hmiAxisSelection: INT := 1; //Not possible to use local hmi variables for array indexes


(******Outputs: Power for Limit switches and Home Sensors (every 4th output)********)
    bSwPower AT %Q*: ARRAY [1..19] OF BOOL;
    i : INT;

//Startup, Shutdown and UPS
    fbUPS: FB_S_UPS_CX51x0;
    eUpsMode: E_S_UPS_Mode := eSUPS_WrPersistData_Shutdown;
    eStartUp: (eColdStart, eReadAxisFeedbackType, eCheckReadDone, eExecuteRestore, eCheckRestore, eFinishRestore);
    bPositionRestoreDone: BOOL := FALSE;
    bRestoreExecute: BOOL := FALSE;
    bExecuteReadEncRefSys: BOOL := FALSE;
    nRetry: INT;
    iAxes : UINT; //index for for loops in Position recovery actions
    afbReadEncRefSys: ARRAY [1..GVL_APP.nAXIS_NUM] OF MC_ReadParameter;
    afbRestorePosition: ARRAY [1..GVL_APP.nAXIS_NUM] OF MC_SetPosition;
    fbGetDeviceIdentification: FB_GetDeviceIdentification;
      
    fbBarnDoor1 :   FB_BarnDoors;
    fbBarnDoor2 :   FB_BarnDoors;
    fbBarnDoor3 :   FB_BarnDoors;
    
    //BACKLASH
    fbBacklashAxis3 : MC_BacklashCompensation;
    fBacklashTestVal : LREAL := 1.41;
    bBacklash   : BOOL;
    
    
    
    //demo test routine data
    fTargetPositions : ARRAY [1..8] OF LREAL;
    BLADE1A : INT:= 1;
    BLADE1B : INT:= 2;
    BLADE2A : INT:= 3;
    BLADE2B : INT:= 4;
    BLADE3A : INT:= 5;
    BLADE3B : INT:= 6;
    GAP1    : INT:= 8;
    GAP2    : INT:= 9;
    GAP3    : INT:= 10;
    bRunDemo    : BOOL :=FALSE;
    iDemoState  : INT:= 0;
    delayTimer : TON;
   
    
    
END_VAR

VAR PERSISTENT
    bRestoreOnStartup : BOOL;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[DEMO();

POSITION_RECOVERY();
PROG();
AXES();

]]></ST>
    </Implementation>
    <Folder Name="POSITION_RECOVERY" Id="{3561f6ef-e145-4ed3-9839-f17334bd2d97}" />
    <Action Name="AXES" Id="{7eb32732-9b53-4934-8cd9-20ba971dd8ff}">
      <Implementation>
        <ST><![CDATA[FOR GVL.iAxis:=1 TO GVL_APP.nAXIS_NUM DO
    aFbAxes[GVL.iAxis](stAxisStruct:=gvl.astAxes[GVL.iAxis]);
END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="CHECK_UPS" Id="{f0f28f50-53b8-4f73-b0f5-6d7ce4c1636f}" FolderPath="POSITION_RECOVERY\">
      <Implementation>
        <ST><![CDATA[fbUPS(eUpsMode := eUpsMode);

IF eGlobalSUpsState = eSUPS_PowerFailure THEN
    //first cycle of powerfailure
    //execute code that should only be done once with each powerfailure, i.e. increase powerfailure counter
    bRestoreOnStartup := TRUE;
    STORE_PERSISTENT();
    RETURN;
ELSIF eGlobalSUpsState <> eSUPS_PowerOK THEN
    //next cycles of powerfailure
    //skip regular code execution for the remaining cycles of the powerfailure/writing of persistent data/quick shutdown...
    RETURN;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="DEMO" Id="{f5daaa00-6794-4f14-becb-81523694a29a}">
      <Implementation>
        <ST><![CDATA[//Demo routine
GVL.astAxes[GAP1].stStatus.bDone:= GVL.astAxes[BLADE1A].stStatus.bDone AND GVL.astAxes[BLADE1B].stStatus.bDone;
GVL.astAxes[GAP2].stStatus.bDone:= GVL.astAxes[BLADE2A].stStatus.bDone AND GVL.astAxes[BLADE2B].stStatus.bDone;
GVL.astAxes[GAP3].stStatus.bDone:= GVL.astAxes[BLADE3A].stStatus.bDone AND GVL.astAxes[BLADE3B].stStatus.bDone;

delayTimer.PT:=T#1S;
delayTimer();

IF NOT bRunDemo THEN
    delayTimer.IN:=TRUE;
END_IF

IF bRunDemo THEN
    CASE iDemoState OF
        0: 
            IF delayTimer.Q THEN
                GVL.astAxes[GAP1].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP1].stConfig.fPosition:= 20;
                GVL.astAxes[GAP1].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP1].stControl.bExecute:= TRUE;
                iDemoState:=1;
                delayTimer.IN:=FALSE;
			END_IF            
        1:
            IF GVL.astAxes[GAP1].stStatus.bDone THEN
                iDemoState:=2;
                delayTimer.IN:= TRUE;            
			END_IF
        2:
            IF delayTimer.Q THEN
                GVL.astAxes[GAP1].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP1].stConfig.fPosition:= 5;
                GVL.astAxes[GAP1].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP1].stControl.bExecute:= TRUE;
                iDemoState:=3;
                delayTimer.IN:= FALSE;
            END_IF
        3:
            //IF GVL.astAxes[iGap1].stStatus.bDone AND GVL.astAxes[1].stStatus.bDone AND GVL.astAxes[2].stStatus.bDone THEN
            IF GVL.astAxes[GAP1].stStatus.bDone THEN
                iDemoState:=4;
                delayTimer.IN:= TRUE; 
			END_IF
        4: 
            IF delayTimer.Q THEN
                GVL.astAxes[GAP2].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP2].stConfig.fPosition:= 20;
                GVL.astAxes[GAP2].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP2].stControl.bExecute:= TRUE;
                iDemoState:=5;
                delayTimer.IN:=FALSE;
			END_IF            
        5:
            IF GVL.astAxes[GAP2].stStatus.bDone THEN
                iDemoState:=6;
                delayTimer.IN:= TRUE;            
			END_IF
        6:
            IF delayTimer.Q THEN
                GVL.astAxes[GAP2].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP2].stConfig.fPosition:= 5;
                GVL.astAxes[GAP2].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP2].stControl.bExecute:= TRUE;
                iDemoState:=7;
                delayTimer.IN:= FALSE;
            END_IF
        7:
            //IF GVL.astAxes[iGap1].stStatus.bDone AND GVL.astAxes[1].stStatus.bDone AND GVL.astAxes[2].stStatus.bDone THEN
            IF GVL.astAxes[GAP2].stStatus.bDone THEN
                iDemoState:=8;
                delayTimer.IN:= TRUE; 
			END_IF
        8: 
            IF delayTimer.Q THEN
                GVL.astAxes[GAP3].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP3].stConfig.fPosition:= 20;
                GVL.astAxes[GAP3].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP3].stControl.bExecute:= TRUE;
                iDemoState:=9;
                delayTimer.IN:=FALSE;
			END_IF            
        9:
            IF GVL.astAxes[GAP3].stStatus.bDone THEN
                iDemoState:=10;
                delayTimer.IN:= TRUE;            
			END_IF
        10:
            IF delayTimer.Q THEN
                GVL.astAxes[GAP3].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP3].stConfig.fPosition:= 5;
                GVL.astAxes[GAP3].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP3].stControl.bExecute:= TRUE;
                iDemoState:=11;
                delayTimer.IN:= FALSE;
            END_IF
        11:
            IF GVL.astAxes[GAP3].stStatus.bDone THEN
                iDemoState:=12;
                delayTimer.IN:= TRUE; 
			END_IF
            
        12: //all together now
            IF delayTimer.Q THEN
                GVL.astAxes[GAP3].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP3].stConfig.fPosition:= 50;
                GVL.astAxes[GAP3].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP3].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP2].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP2].stConfig.fPosition:= 50;
                GVL.astAxes[GAP2].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP2].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP1].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP1].stConfig.fPosition:= 50;
                GVL.astAxes[GAP1].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP1].stControl.bExecute:= TRUE;
                iDemoState:=13;
                delayTimer.IN:= FALSE;
            END_IF
        13:
            IF GVL.astAxes[GAP3].stStatus.bDone AND GVL.astAxes[GAP2].stStatus.bDone AND GVL.astAxes[GAP1].stStatus.bDone THEN
                iDemoState:=14;
                delayTimer.IN:= TRUE; 
			END_IF
        14: //all together now
            IF delayTimer.Q THEN
                GVL.astAxes[GAP3].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP3].stConfig.fPosition:= 40;
                GVL.astAxes[GAP3].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP3].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP2].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP2].stConfig.fPosition:= 30;
                GVL.astAxes[GAP2].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP2].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP1].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP1].stConfig.fPosition:= 20;
                GVL.astAxes[GAP1].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP1].stControl.bExecute:= TRUE;
                iDemoState:=15;
                delayTimer.IN:= FALSE;
            END_IF
        15:
            IF GVL.astAxes[GAP3].stStatus.bDone AND GVL.astAxes[GAP2].stStatus.bDone AND GVL.astAxes[GAP1].stStatus.bDone THEN
                iDemoState:=16;
                delayTimer.IN:= TRUE; 
			END_IF
        16: //all together now
            IF delayTimer.Q THEN
                GVL.astAxes[GAP3].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP3].stConfig.fPosition:= 20;
                GVL.astAxes[GAP3].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP3].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP2].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP2].stConfig.fPosition:= 30;
                GVL.astAxes[GAP2].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP2].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP1].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP1].stConfig.fPosition:= 40;
                GVL.astAxes[GAP1].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP1].stControl.bExecute:= TRUE;
                iDemoState:=17;
                delayTimer.IN:= FALSE;
            END_IF
        17:
            IF GVL.astAxes[GAP3].stStatus.bDone AND GVL.astAxes[GAP2].stStatus.bDone AND GVL.astAxes[GAP1].stStatus.bDone THEN
                iDemoState:=18;
                delayTimer.IN:= TRUE; 
			END_IF
        18: //all together now
            IF delayTimer.Q THEN
                GVL.astAxes[GAP3].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP3].stConfig.fPosition:= 15;
                GVL.astAxes[GAP3].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP3].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP2].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP2].stConfig.fPosition:= 15;
                GVL.astAxes[GAP2].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP2].stControl.bExecute:= TRUE;
                GVL.astAxes[GAP1].stControl.eCommand:=E_MotionFunctions.eMoveAbsolute;
                GVL.astAxes[GAP1].stConfig.fPosition:= 15;
                GVL.astAxes[GAP1].stConfig.fVelocity:= 5;
                GVL.astAxes[GAP1].stControl.bExecute:= TRUE;
                iDemoState:=19;
                delayTimer.IN:= FALSE;
            END_IF
        19:
            IF GVL.astAxes[GAP3].stStatus.bDone AND GVL.astAxes[GAP2].stStatus.bDone AND GVL.astAxes[GAP1].stStatus.bDone THEN
                iDemoState:=0;
                delayTimer.IN:= TRUE; 
			END_IF
    END_CASE
END_IF]]></ST>
      </Implementation>
    </Action>
    <Method Name="enableAxis" Id="{caaa806d-b297-4b20-b923-b6e7fafefc93}">
      <Declaration><![CDATA[METHOD enableAxis : BOOL
VAR_INPUT
    iAxis : UINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[GVL.astAxes[iAxis].stConfig.fOverride:=100;
GVL.astAxes[iAxis].stControl.bEnable:= TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Action Name="POSITION_RECOVERY" Id="{28e203b7-aea5-42d0-980d-12a6841f9d22}" FolderPath="POSITION_RECOVERY\">
      <Implementation>
        <ST><![CDATA[fbGetDeviceIdentification(bExecute := TRUE);
IF (fbGetDeviceIdentification.stDevIdent.strHardwareSerialNo <> '0') THEN
    CHECK_UPS();
    RESTORE_POSITIONS();
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="PROG" Id="{5d03ebbb-2a47-4890-ad6d-e82daf72dc51}">
      <Implementation>
        <ST><![CDATA[(*MUON BARN DOORS*)
(*This application uses a set position functionblock to update
the gap size value of a virtual axis based on two real world barn door blades.
The gap size is limited by the geometry of the jaws defined by the closed gap size and the blade size*)

//All outputs powering limits turned on.
FOR i:=1 TO 19 DO
    bSwPower[i]:= TRUE;
END_FOR

//Select homing routine to use for each axis
GVL.astAxes[1].stConfig.eHomeSeq:=E_HomingRoutines.eHomeToEncPulse_viaFwdLimit;
GVL.astAxes[2].stConfig.eHomeSeq:=E_HomingRoutines.eHomeToEncPulse_viaBwdLimit;
GVL.astAxes[3].stConfig.eHomeSeq:=E_HomingRoutines.eHomeToEncPulse_viaFwdLimit;
GVL.astAxes[4].stConfig.eHomeSeq:=E_HomingRoutines.eHomeToEncPulse_viaBwdLimit;
GVL.astAxes[5].stConfig.eHomeSeq:=E_HomingRoutines.eHomeToEncPulse_viaFwdLimit;
GVL.astAxes[6].stConfig.eHomeSeq:=E_HomingRoutines.eHomeToEncPulse_viaBwdLimit;

//Set calibrated home position for each axis
GVL.astAxes[1].stConfig.fHomePosition:=-11.189; //was -10.09  (-8.7)
GVL.astAxes[2].stConfig.fHomePosition:=-2.495; //was 13.75 (12.2)
GVL.astAxes[3].stConfig.fHomePosition:=-3.83; //was -3.19 (-4.19) (-2.55
GVL.astAxes[4].stConfig.fHomePosition:=15.61; //was 14.26 (15.66)
GVL.astAxes[5].stConfig.fHomePosition:=-10.097; //was -9.8
GVL.astAxes[6].stConfig.fHomePosition:=8.55; //9.45 (9.43)

//Call function blocks with blade numbers and gap geometry.
fbBarnDoor1(bladeA:=1,bladeB:=2,gap:=8,fClosedGap:=1.10,fBladeSize:=64.4175); //New blade sizes taken from survey data with Tony Millington. BLADE SIZE WAS 62.94
fbBarnDoor2(bladeA:=3,bladeB:=4,gap:=9,fClosedGap:=1.45,fBladeSize:=64.4475);
fbBarnDoor3(bladeA:=5,bladeB:=6,gap:=10,fClosedGap:=1.49,fBladeSize:=64.4005);]]></ST>
      </Implementation>
    </Action>
    <Action Name="RESTORE_POSITIONS" Id="{0c7ee537-7bd9-4833-b428-c17cbb57e893}" FolderPath="POSITION_RECOVERY\">
      <Implementation>
        <ST><![CDATA[//This ACT will restore the position of an incremental axis on startup with the act position it read before losing power.
//It checks the type of axis, 0=incremental, and that the axis was stationary at shut down.
//Because 0 equates to incremental we also need to check that the data is valid, otherwise by default it would restore all axes.
//By default an axis will not restore the position unless it is set to opt-in, i.e. GVL.aAxes[iAxes].stConfig.eRestorePosition is non-zero.
//This needs to be initialised somewhere in TwinCAT code otherwise it will not be available at start up.
//A restore will only be performed on a loss of power, this code shouldn't make any changes on a reset cold, a rest origin or a download.
//There is a enum to allow for different types of restore modes, currently only one is implemented.
//0 'DontRestore'
//1 'RestoreWithoutHome' -restores the position using a set position fb and does not set the home bit in the axis struct.
//Note from Beckhoff: "A maximum of 1 MB persistent data can be reliably saved over the entire service life."

IF bRestoreOnStartup AND eGlobalSUpsState = eSUPS_PowerOK THEN
    bRestoreOnStartup := FALSE;
    bRestoreExecute := TRUE;
END_IF

//Upon startup bPositionRestoreDone will be set to FALSE, after successfully completing the following code it will be set TRUE
//and should stay TRUE for the rest of the time the PLC is operational, thus this routine should only be completed once.
IF bRestoreExecute AND NOT bPositionRestoreDone THEN
    //Cycle through function blocks that read the encoder reference system i.e. whether axis is incremental or absolute
    //Result stored in Value, 0=Inc 1=Abs, execute set during the case statement
    FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
        afbReadEncRefSys[iAxes](
          Axis := GVL.astAxes[iAxes].Axis,
          Enable := bExecuteReadEncRefSys,
          ParameterNumber := MC_AxisParameter.AxisEncoderReferenceSystem,
          ReadMode := E_READMODE.READMODE_ONCE);
    END_FOR

    //Cycle through set position function blocks for each axis
    FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
        afbRestorePosition[iAxes](
         Axis := GVL.astAxes[iAxes].Axis,
         Position := astAxesPersistent[iAxes].fPositionAtShutdown);
    END_FOR

    CASE eStartUp OF
        eColdStart:
        //First cycle of the PLC, do nothing just give one cycle for variables to initialise
            IF NOT bPositionRestoreDone THEN
                eStartUp := eReadAxisFeedbackType;
                nRetry := 0;
            END_IF

        eReadAxisFeedbackType:
        //Exectute the function blocks to read the encoder reference system (0=inc OR 1=ABS)
            bExecuteReadEncRefSys := TRUE;
            eStartUp := eCheckReadDone;

        eCheckReadDone:
        //Check the encoder reference system has been read for all axis -> if busy then continue with PLC cycle and check again next time.
        //If afbReadEncRefSys not started then go back a step.
        //If any axes result in an error the code will get stuck here, this happens if GVL_APP.nAXIS_NUM is not set correctly
            FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
                IF afbReadEncRefSys[iAxes].Valid = FALSE THEN
                    IF afbReadEncRefSys[iAxes].Busy = TRUE THEN
                        //Exit MAIN.STARTUP Action and wait till next cycle, needs to cycle through whole program in order for data to update
                        RETURN;
                    ELSE
                        //Sometimes the code gets here and the afbReadEncRefSys[iAxes] misses the rising edge. If  the code gets here it means
                        //valid=FALSE and .busy=FALSE which indicateds the FB probably hasn't started and thus needs to see a rising edge.
                        //Set execute to low, Exit MAIN.STARTUP and go back a step in the CASE statement.
                        bExecuteReadEncRefSys := FALSE;
                        eStartUp := eReadAxisFeedbackType;
                        nRetry := nRetry + 1; //counter used for troubleshooting to see how many cycles it takes before afbReadEncRefSys function blocks are read correctly
                        RETURN;
                    END_IF
                END_IF
            END_FOR
            //If the code gets here all axes either have .valid=TRUE for all axes
            eStartUp := eExecuteRestore;

        eExecuteRestore:
        //Execute position restore by setting afbRestorePosition.execute = TRUE
            FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
                IF afbReadEncRefSys[iAxes].Valid = TRUE AND afbReadEncRefSys[iAxes].Value = 0 AND NOT(astAxesPersistent[iAxes].bMovingAtShutdown) THEN
                    IF GVL.astAxes[iAxes].stConfig.eRestorePosition = E_RestorePosition.eRestoreWithoutHome THEN
                        afbRestorePosition[iAxes].Execute := TRUE;
                    END_IF
                END_IF
            END_FOR
            eStartUp := eCheckRestore;

        eCheckRestore:
        //Check the set position fbs are finished
        //Nothing actually happens if the restore is not done, the code just returns from here each cycle and the
        //bPositionRestoreDone will never get set to TRUE and will take up cycle time
            FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
                IF afbReadEncRefSys[iAxes].Valid = TRUE AND afbReadEncRefSys[iAxes].Value = 0 AND NOT(astAxesPersistent[iAxes].bMovingAtShutdown) THEN
                    IF GVL.astAxes[iAxes].stConfig.eRestorePosition = E_RestorePosition.eRestoreWithoutHome THEN
                        IF NOT afbRestorePosition[iAxes].Done THEN
                            RETURN;
                        END_IF
                    END_IF
                END_IF
            END_FOR
            eStartUp := eFinishRestore;

        eFinishRestore:
        //Remove execute = TRUE for afbRestorePosition
            FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
                afbRestorePosition[iAxes].Execute := FALSE;
            END_FOR
            bPositionRestoreDone := TRUE;
            bRestoreExecute := FALSE;
    END_CASE
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="STORE_PERSISTENT" Id="{cb5c9254-2e5f-47b1-9baa-10e728a961b0}" FolderPath="POSITION_RECOVERY\">
      <Implementation>
        <ST><![CDATA[FOR iAxes := 1 TO GVL_APP.nAXIS_NUM DO
    astAxesPersistent[iAxes].fPositionAtShutdown := GVL.astAxes[iAxes].Axis.NcToPlc.ActPos;
    IF GVL.astAxes[iAxes].Axis.NcToPlc.ActVelo <> 0 THEN
        astAxesPersistent[iAxes].bMovingAtShutdown := TRUE;
    ELSE
        astAxesPersistent[iAxes].bMovingAtShutdown := FALSE;
    END_IF
    astAxesPersistent[iAxes].bMovingAtShutdown := astAxesPersistent[iAxes].bMovingAtShutdown OR GVL.astAxes[iAxes].Axis.Status.Moving;
END_FOR]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="MAIN">
      <LineId Id="772" Count="0" />
      <LineId Id="832" Count="0" />
      <LineId Id="505" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="640" Count="0" />
      <LineId Id="658" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.AXES">
      <LineId Id="1" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.CHECK_UPS">
      <LineId Id="14" Count="11" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.DEMO">
      <LineId Id="2" Count="1" />
      <LineId Id="79" Count="1" />
      <LineId Id="4" Count="6" />
      <LineId Id="47" Count="0" />
      <LineId Id="12" Count="10" />
      <LineId Id="24" Count="0" />
      <LineId Id="26" Count="18" />
      <LineId Id="51" Count="27" />
      <LineId Id="50" Count="0" />
      <LineId Id="82" Count="23" />
      <LineId Id="107" Count="2" />
      <LineId Id="81" Count="0" />
      <LineId Id="110" Count="1" />
      <LineId Id="113" Count="4" />
      <LineId Id="123" Count="2" />
      <LineId Id="118" Count="0" />
      <LineId Id="126" Count="2" />
      <LineId Id="121" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="112" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="131" Count="2" />
      <LineId Id="130" Count="0" />
      <LineId Id="135" Count="20" />
      <LineId Id="134" Count="0" />
      <LineId Id="156" Count="42" />
      <LineId Id="45" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.enableAxis">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="1" />
    </LineIds>
    <LineIds Name="MAIN.POSITION_RECOVERY">
      <LineId Id="6" Count="3" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.PROG">
      <LineId Id="3" Count="0" />
      <LineId Id="136" Count="2" />
      <LineId Id="174" Count="1" />
      <LineId Id="155" Count="2" />
      <LineId Id="176" Count="0" />
      <LineId Id="158" Count="6" />
      <LineId Id="177" Count="0" />
      <LineId Id="165" Count="5" />
      <LineId Id="149" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="171" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="154" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.RESTORE_POSITIONS">
      <LineId Id="242" Count="105" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.STORE_PERSISTENT">
      <LineId Id="11" Count="7" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>